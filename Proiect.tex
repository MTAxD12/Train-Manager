\documentclass[runningheads]{llncs}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{amsmath}
\usepackage{float}
\usepackage{tikz}
\usepackage{enumitem}
\usetikzlibrary{shapes.geometric, arrows}

\lstset{
  language=C,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{green!60!black},
  stringstyle=\color{red!60!black},
  showstringspaces=false,
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=10pt,
  breaklines=true,
  frame=tb,
  columns=flexible,
  backgroundcolor=\color{gray!10},
  escapeinside={(*@}{@*)}
}

\title{Sistem de Gestionare a Informatiilor Feroviare}
\author{Preda Andrei-Claudiu\orcidID{2A2}} 
\institute{{Universitatea "Alexandru Ioan Cuza" Iasi,\\
Facultatea de Informatica}\\
\email andrei.foco@yahoo.com}
\authorrunning{Preda Andrei-Claudiu}
\begin{document}

\maketitle

\begin{abstract}
Acest raport prezinta implementarea unei aplicatii client-server pentru gestionarea informatiilor referitoare la trenuri folosind protocolul TCP/IP. Sunt descrise arhitectura aplicatiei, tehnologiile utilizate si detaliile de implementare.
\end{abstract}

\section{Introducere}
Scopul acestui proiect este dezvoltarea unui sistem client-server care permite gestionarea informatiilor despre plecarile, sosirile si intarzierile trenurilor. Aplicatia ofera suport pentru comunicarea intre client si server prin intermediul conexiunilor TCP. Obiectivele principale includ implementarea unui protocol personalizat si gestionarea concurenta a conexiunilor multiple prin utilizarea firelor de executie (threads).

\section{Tehnologii Aplicate}
Aplicatia utilizeaza urmatoarele tehnologii si concepte:
\begin{itemize}
    \item \textbf{TCP/IP}: Protocolul TCP este utilizat pentru asigurarea unei comunicatii fiabile intre client si server.
    \item \textbf{Sockets}: Atat clientul, cat si serverul folosesc socket-uri pentru a trimite si primi date.
    \item \textbf{Pthreads}: Serverul foloseste fire de executie pentru a servi mai multi clienti simultan.
    \item \textbf{Sisteme de fisiere}: Datele despre trenuri sunt stocate si prelucrate din fisiere XML.
    \item \textbf{C Standard Library}: Biblioteci standard C pentru operatiuni de I/O, manipulare de siruri de caractere si gestionarea timpului.
\end{itemize}

\section{Structura Aplicatiei}

\subsection{Concepte Folosite}
In aceasta sectiune sunt descrise conceptele utilizate in implementarea serverului si clientului.

\subsubsection*{I. Functionarea serverului multithreaded}
Serverul este implementat folosind mai multe thread-uri pentru a deservi cererile clientilor. Principalele concepte includ:
\begin{itemize}
    \item \textbf{Thread-uri:} Fiecare client este servit intr-un thread separat. Structura \texttt{Thread} gestioneaza informatiile despre fiecare thread:
    \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
typedef struct {
    pthread_t idThread; // ID-ul thread-ului
    int thCount;        // Nr. de conexiuni servite
} Thread;
    \end{lstlisting}
    
    \item \textbf{ClientState:} Structura \texttt{ClientState} este utilizata pentru a stoca informatiile despre clienti, cum ar fi socket-ul asociat, starea de autentificare, thread-ul care serveste clientul si numele de utilizator:
    \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
typedef struct {
    int socket;         // Socket-ul clientului
    int logged_in;      // 1 = este autentificat, 0 = nu este
    int thread;         // ID-ul thread-ului asociat
    char username[50];  // Numele de utilizator
} ClientState;
    \end{lstlisting}
    
    \item \textbf{Mutex:} Mutex-ul \texttt{mlock} este folosit pentru a sincroniza accesul la acceptarea conexiunilor:
    \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
pthread_mutex_t mlock = PTHREAD_MUTEX_INITIALIZER;
    \end{lstlisting}
    
    \item \textbf{Functia \texttt{treat()}:} Thread-urile accepta conexiuni si gestioneaza comenzile clientului:
    \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
pthread_create(&threadsPool[i].idThread, NULL, &treat, (void *)(intptr_t)i);
    \end{lstlisting}
\end{itemize}

\subsubsection*{II. Structura datelor pentru informatii despre trenuri}
Serverul utilizeaza mai multe structuri pentru a gestiona informatiile despre trenuri, exceptii si statii:

\begin{itemize}
    \item \textbf{Structura \texttt{ExceptionInfo}:} Specifica perioada sau perioadele in care trenul circula:
    \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
typedef struct {
    char dataStart[11];   // Format DD.MM.YYYY
    char dataFinal[11];   // Format DD.MM.YYYY
} ExceptionInfo;
    \end{lstlisting}
    \vspace{1cm}
    
    \item \textbf{Structura \texttt{TrainInfo}:} Stocheaza informatiile detaliate despre un tren, incluzand intarzieri, statii intermediare si exceptii de circulatie:
    \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
typedef struct {
    char id[16];                // ID-ul trenului
    char statiePlecare[50];     // Statia de plecare
    char statieSosire[50];      // Statia de sosire
    char oraPlecare[10];        // Ora de plecare
    char oraSosire[10];         // Ora de sosire
    int intarzierePlecare;      // Intarzierea la plecare (minute)
    int intarziereSosire;       // Intarzierea la sosire (minute)
    Station statii[MAX_STATIONS];  // Lista statiilor intermediare
    int nrStatii;               // Numarul total de statii intermediare
    ExceptionInfo exceptii[MAX_EXCEPTIONS]; // Lista exceptiilor
    int nrExceptii;             // Numarul de exceptii
    int circulaAzi;             // Indicator daca trenul circula astazi (1 = Da, 0 = Nu)
} TrainInfo;
    \end{lstlisting}
    
    \item \textbf{Structura \texttt{Station}:} Reprezinta o statie intermediara, incluzand orele de sosire, plecare si eventuale intarzieri:
    \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
typedef struct {
    char nume[50];        // Numele statiei
    char oraSosire[10];   // Ora de sosire in statie
    char oraPlecare[10];  // Ora de plecare din statie
    int intarziere;       // Intarzierea in statie (minute)
} Station;
    \end{lstlisting}
\end{itemize}

\subsubsection*{III. Interactiunea client-server}

Interactiunea client-server utilizeaza socket-uri TCP pentru comunicarea bidirectionala. Serverul raspunde cererilor clientului in functie de comanda primita. Exista doua tipuri principale de raspunsuri, care influenteaza comportamentul clientului: 
1. Raspuns simplu (mesaj scurt).
2. Raspuns multiplu (mesaj lung). Acestea sunt gestionate diferit pe baza protocolului de comunicare.

\paragraph{Etapele principale ale comunicarii:}

\begin{enumerate}[label=\alph*)]
    \item \textbf{Initializarea conexiunii:}
    \begin{itemize}
        \item Clientul creeaza un socket utilizand \texttt{socket()} si stabileste conexiunea la server cu \texttt{connect()}.
        \item Serverul asculta conexiunile folosind \texttt{bind()}, \texttt{listen()} si accepta conexiunile clientilor folosind \texttt{accept()}.
    \end{itemize}

    \vspace{2cm}
    \item \textbf{Trimiterea unei comenzi de catre client:}
    Clientul introduce o comanda in linia de comanda, care este citita cu \texttt{read()} si transmisa catre server cu \texttt{write()}:
    \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
printf("Introduceti comanda: ");
fflush(stdout);
read(0, comanda, sizeof(comanda));
write(socket_client, comanda, strlen(comanda) + 1);
    \end{lstlisting}
    \item \textbf{Procesarea raspunsului serverului:}
    Serverul raspunde pe baza comenzii primite. Clientul distinge intre cele doua tipuri de raspunsuri:
    \begin{itemize}
        \item **Raspuns simplu** (ex. un mesaj scurt):
        \begin{itemize}
            \item Daca raspunsul serverului nu contine cuvantul cheie \texttt{sirLung}, atunci clientul il afiseaza direct:
            \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
if (!strstr(raspuns, "sirLung")) {
    printf("Raspuns de la server: %s\n\n", raspuns);
}
            \end{lstlisting}
        \end{itemize}
        
        \item **Raspuns multiplu** (ex. mesaj lung transmis in bucati):
        \begin{itemize}
            \item Daca raspunsul serverului contine cuvantul cheie \texttt{sirLung}, clientul intra intr-un ciclu de citire continua pana cand primeste mesajul \texttt{END}. 
            \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
if (strstr(raspuns, "sirLung")) {
    while (strcmp(raspuns, "END") != 0) {
        memset(raspuns, 0, sizeof(raspuns));
        read(socket_client, raspuns, sizeof(raspuns));
        if (strcmp(raspuns, "END") == 0) break;
        printf("%s\n", raspuns);
        fflush(stdout);
    }
    printf("\n");
}
            \end{lstlisting}
        \end{itemize}
    \end{itemize}

    \item \textbf{Finalizarea comunicarii:}
    \begin{itemize}
        \item Daca clientul trimite comanda \texttt{quit}, serverul inchide conexiunea. Clientul gestioneaza aceasta situatie iesind din bucla principala de executie.
        \item Conexiunea este inchisa utilizand functia \texttt{close()}:
        \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
if (strcmp(comanda, "quit") == 0) {
    break;
}
close(socket_client);
        \end{lstlisting}
    \end{itemize}
\end{enumerate}

\paragraph{Avantajele acestei abordari:}
\begin{itemize}
    \item Flexibilitate: Permite procesarea unor raspunsuri complexe, inclusiv a mesajelor lungi, fara a limita dimensiunea initiala a bufferului.
    \item Gestionarea eficienta a resurselor: Serverul poate trimite raspunsuri in bucati pentru a evita supraincarcarea memoriei.
\end{itemize}


\subsection{Diagrama Aplicatiei}
\vspace{-10pt}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{Untitled2.png}
    \label{fig:enter-label}
\end{figure}
\section{Aspecte de Implementare}

\subsection{Codul Serverului}
Serverul este implementat in limbajul C si foloseste socket-uri si fire de executie pentru a gestiona comunicarea cu clientii.

\begin{lstlisting}[caption={Fragment de cod din server.c}, label={lst:server-code}]
void response_manage(int cl, int idThread)
{
    char comanda[1024];
    char raspuns[1024]; 
    ssize_t bytes_read;

    while(1)
    {
        memset(comanda, 0, sizeof(comanda));
        bytes_read = read(cl, comanda, sizeof(comanda) - 1);
        if (bytes_read <= 0) return;

        if (strncmp(comanda, "login", 5) == 0) {
            char user[50], parola[50];
            if (sscanf(comanda, "login %49s %49s", user, parola) == 2) {
                snprintf(raspuns, sizeof(raspuns), "login reusit: %s", user);
            } else {
                strcpy(raspuns, "Format invalid. Folositi: login <user> <parola>");
            }
        }
        write(cl, raspuns, strlen(raspuns));
    }
}
\end{lstlisting}
\subsection{Protocolul Aplicatiei}
Protocolul defineste urmatoarele comenzi:
\begin{itemize}
    \item \textbf{login \textlangle user\textrangle \textlangle parola\textrangle} - autentificare client (optional - doar pentru utilizarea comenzii \textbf{intarziere}).
    \item \textbf{logout} - delogheaza clientul.
    \item \textbf{plecari \textlangle numeOras\textrangle} [data] - afiseaza plecarile dintr-un oras (daca nu este precizata o data, se utilizeaza data curenta).
    \item \textbf{sosiri \textlangle numeOras\textrangle} [data] - afiseaza sosirile intr-un oras (daca nu este precizata o data, se utilizeaza data curenta).
    \item \textbf{trenuri \textlangle numeOras\textrangle [DD.MM.YYYY]} - afiseaza mersul trenurilor dintr-un oras la data oferita (optional).
    \item \textbf{info \textlangle idTren\textrangle} - ofera informatii despre trenul specificat.
    \item \textbf{intarziere \textlangle idTren\textrangle \textlangle statie\textrangle \textlangle nrMinute\textrangle} - adauga o intarziere in minute pentru trenul specificat.
    \item \textbf{reset} - reseteaza toate intarzierile trenurilor (disponibila doar pentru clientii logati).
    \item \textbf{quit} - deconecteaza clientul.
\end{itemize}

\subsection{Scenarii Reale de Utilizare}
\begin{itemize}
    \item Un client trimite comanda `plecari Bucuresti Nord 10.06.2024` pentru a obtine plecarile din Bucuresti la o anumita data.
    \item Un client logat trimite comanda `intarziere IR1660 Iasi 15` pentru a adauga o intarziere de 15 minute trenului cu ID-ul IR1660, incepand cu statia Iasi.
    \item Un client logat trimite comanda `reset` pentru a reseta intarzierile trenurilor.
\end{itemize}

\section{Concluzii}
Aplicatia dezvoltata permite gestionarea eficienta a informatiilor despre trenuri prin intermediul unui protocol simplu implementat folosind TCP. In urma testarii si evaluarii functionalitatii, pot fi aduse urmatoarele imbunatatiri:

\begin{itemize}
    \item \textbf{Adaugarea unui mecanism de autentificare mai complex} – Implementarea unor protocoale de securitate avansate, precum autentificarea pe baza de token-uri.
    \item \textbf{Realizarea unei interfete grafice pentru client} – O interfata grafica ar imbunatati experienta utilizatorilor, oferindu-le un mod mai intuitiv si mai prietenos de interactionare cu aplicatia.
    \item \textbf{Implementarea unui sistem de notificari} – Adaugarea unui sistem de notificari care sa informeze utilizatorii despre intarzierea trenurilor sau modificari de program ar imbunatati serviciile oferite.
    \item \textbf{Extinderea functionalitatii cu optiuni suplimentare} – Posibilitatea de a consulta informatii suplimentare, cum ar fi tarifele biletelor, disponibilitatea locurilor sau conditiile meteo in statiile respective, ar adauga valoare aplicatiei.
\end{itemize}

\section*{Referinte}
\begin{thebibliography}{9}
\bibitem{tcp-ip}
Douglas E. Comer, \textit{Internetworking with TCP/IP: Principles, Protocols, and Architecture}, Prentice Hall, 2006.

\bibitem{sockets}
Richard Stevens, \textit{Unix Network Programming}, Addison-Wesley, 1998.
\end{thebibliography}

\end{document}
